# U6 - Almacenamiento Secundario: Discos magneticos

Plato circular construido de un material no magn칠tico, llamado substrato (aluminio o vidrio), cubierto por un material magnetizable

### Mecanismos de lectura/escritura magn칠tico
Tenian una cabeza de lectura/escritura 칰nica: bobina conductora est치tica, el disco est치 girando constantemente debajo de ella. Y era usado en los viejos discos r칤gidos y floppy disk.

Actualmente la cabeza de lectura esta diferenciada de la de escritura
- Tiene un sensor magneto-resistivo (MR)
- La resistencia el칠ctrica del material depende de la direcci칩n de la magnetizaci칩n del medio que se mueve por debajo
- Se hace pasar una corriente a trav칠s del sensor MR y los cambios de resistencia se detectan como se침ales de voltaje
- Provee mayores densidades de grabaci칩n y velocidades de operaci칩n que el mecanismo anterior

![dddd](https://github.com/user-attachments/assets/ebb9078a-e2f5-4f88-a6b8-ad24f902f867)

#### Lectura
Cada cubito (los que dicen N (norte) S (sur)) almacenan 1 bit y la flecha que tienen indica la polaridad del magnetismo. Si la polaridad (la flechita) va para un lado o para el otro el MR va a resistir mas o menos corriente, se censa esa corriente y se define si en el bloquecito hay un 1 o un 0.
#### Escritura
A traves de una bovina conductora con material que hace que circule corriente electrica se genera un campo magnetico y los patrones magneticos resultantes (definiendose un N o S) se graban en la superficie.

## Organizacion
- Pistas conc칠ntricas
- El ancho de la pista es igual al ancho de la cabeza lectora/grabadora
- Entre las pistas hay un gap (**Intertrack gap**) para minimizar errores de desalineamiento de la cabeza e interferencias magn칠ticas
- La superficie del disco est치 subdividida en sectores, en general de tama침o fijo (512 bytes)
- Hay un gap (**Intersector gap**) entre los sectores para evitar errores de sincronizaci칩n

![eeee](https://github.com/user-attachments/assets/3c15c688-6597-4e5b-86fe-92716eaa6b25)

- **CAV** (Constant Angular Velocity): el disco gira a velocidad constante. Entonces la cabeza lectora/grabadora puede operar a la misma tasa de transferencia.
- Los bits exteriores giran a mayor velocidad que los interiores (velocidad lineal variable). Pero para compensar, los bits exteriores est치n m치s espaciados entre s칤
- **Ventaja:** se puede referenciar a cada bloque de informaci칩n a trav칠s de pista/sector
- **Desventaja:** no se aprovecha el m치ximo de densidad (bits por pulgada lineal) de la superficie del disco por el espacio entre sectores

### Grabacion multizona
- La superficie del disco se divide en zonas conc칠ntricas (por lo general 16). 
- La cantidad de bits por pista dentro de una zona es constante
- Las zonas exteriores contienen m치s bits por pulgada (m치s sectores) que las zonas interiores
- **Ventaja:** mayor capacidad de almacenamiento. En este tipo de organizacion aparecen mas sectores
- **Desventajas:** mayor complejidad en la circuiter칤a para trabajar con tiempos de lectura/escritura diferentes seg칰n la zona (la longitud de los bits var칤a)

![ffff](https://github.com/user-attachments/assets/f91b7891-d308-4411-a1aa-0ea5af0bbb10)

![gggg](https://github.com/user-attachments/assets/e3456dc1-fd88-41d1-9ca9-6c3f580819fb)

## Caracteristicas fisicas

### Movimiento de la cabeza
- **Fija:** hab칤a una cabeza lectora/grabadora por pista (muy costosos, no se usan m치s) Ej. IBM 2305
- **M칩vil:** hay una 칰nica cabeza lectora/grabadora por superficie del plato. Se mueve por todas las pistas y est치 montada en un brazo

![hhhh](https://github.com/user-attachments/assets/04a2901b-9d4d-4adc-8b84-6ced5f2d146a)

Todas las cabezas por disco funcionan igual, sincronizadas, hay una cabeza por cada superficie.

### Portabilidad
- **Discos no removibles:** disco r칤gido (se monta en un disk drive)
- **Removibles:** se puede sacar y poner en la unidad (Ej. floppy disk)

### Lados
- **Un solo lado:** solo es usable una cara
- **Dos lados:** el recubrimiento magn칠tico est치 en ambas caras

 ### Platos
- **Un solo plato**
- **M칰ltiples platos:** varios discos en un mismo disk drive
- **Cilindro:** conjunto de pistas que est치n a la misma distancia relativa del centro en los platos de un disk drive

### Mecanismo de la cabeza
- **Contacto:** toma contacto con la superficie del disco (Ej. floppy)
- **Espacio fijo:** se ubica a una posici칩n fija por encima del disco
- **Espacio aerodin치mico (flotante):** se ubica flotante por sobre el disco gracias a la presi칩n de aire que genera la rotaci칩n del disco

## Concepto de cluster
A **sector** is the smallest physical storage unit on the disk, and on most file systems it is fixed at 512 bytes in size. A **cluster** can consist of one or more consecutive sectors.

To the file system 1 cluster is one unit of storage. Anything larger than 1 cluster uses multiple cluster. Anything smaller uses 1 cluster.

![c](https://github.com/user-attachments/assets/ed165aeb-5191-455d-928d-d8a29520e59f)

El `Tama침o` es el el tama침o real y el `Tama침o en disco` es un multiplo de lo que almacene un cluster, o sea lo que va a ocupar en realidad el archivo en el disco. La diferencia entre ambos numeros es lo que queda sin usar del disco lo que se estaria perdiendo.

## Par치metros de performance
- <ins>Desempe침o del disco:</ins> depende del computador, sistema operativo, m칩dulo de E/S y controlador de disco
- <ins>Tiempo de seek:</ins> tiempo necesario para que la cabeza lectora/grabadora se posicione en la pista correcta
- <ins>Tiempo de demora rotacional o latencia:</ins> tiempo de espera hasta que el sector deseado pasa por la cabeza lectora/grabadora 
- <ins>Tiempo de acceso:</ins> tiempo necesario para estar en posici칩n para escribir o leer
    - `Tiempo acceso = tiempo de seek promedio + tiempo de latencia promedio`
- <ins>Tiempo de transferencia:</ins> tiempo necesario para transferir la informaci칩n al disco
    - `T = b/rN` donde `T` = tiempo de transf.; `b` = bytes a transf.; `r` = velocidad de rotaci칩n en revoluciones por segundo; `N` = bytes por pista
- <ins>Tiempo total lectura/escritura</ins>: tiempo necesario para transferir la informaci칩n al disco
    - `T = Tseek + 1 / 2r + b / rN` donde `r` = velocidad de rotaci칩n en revoluciones por segundo; `b` = bytes a transferir; `N` = bytes por pista

# Discos magneticos: RAID (Redundant Array of Independent Disks)

- Vectores de discos que funcionan como entidades independientes y pero sincronizadas en paralelo. Aunque sea mas de una entidad, para el usuario se visualizan como una unica unidad logica.
- **Paralelismo:** se puede manejar un pedido de E/S en paralelo su los datos residen en discos separados. Debido a que los datos est치n distribuidos, el sistema puede leer o escribir en varios discos al mismo tiempo. Esto significa que si un usuario solicita datos que est치n en diferentes discos, el sistema puede acceder a esos datos en paralelo, mejorando el rendimiento.
- Se brinda confiabilidad a los datos, por poder recuperar informacion, poder corregir errores, y maneras de organizar la informacion.
- **RAID** es un estandar que consiste en 7 niveles (0 a 6). Pueden implementarse combinaciones de niveles.
- Entra el concepto de **Redundancia:** duplicacion de la informacion para aumentar la cofiabilidad y la disponibilidad del sistema.
- Y el concepto de **Paridad**: parity is a means to achieve data redundancy without incurring the same degree of cost as that of mirroring in terms of disk usage and write performance.

### Caracteristicas principales
- Es un conjunto de discos que son vistos por el OS como una unica unidad logica
- Los datos se distribuyen en los discos del vector en un esquema llamado *striping*. Cuando se graba un archivo, ese archivo se divide en peque침as partes que se llaman *strip*
- Menos en el RAID 0, existen tecnicas de redundancia y de paridad para garantizar la recuperacion ante fallas

## Nivel 0 (Stripping)
- No existe la redundancia
- Se requieren N discos
- Se distribuyen los datos en el vector de discos en strips (pueden ser sectores, bloques u otra unidad)

游릭 **Ventajas:**
- La performance la E/S es mucho mejor porque se distribuye esa carga.
- Dise침o simple y facil implementacion

游댮 **Densventaja:**
- Riesgo ante fallos, no hay recuperacion posible, hay poca confiabilidad. El fallo en un solo disco significa que se va a perder toda la informacion en un array de datos.

Si se quiere grabar un archivo, el archivo se divide en strips

![r0](https://github.com/user-attachments/assets/ef2cdabc-e0b9-4d35-bd41-1e270bd419e6)

Todos los discos estan conectados fisicamente a una placa, el controlador RAID, que a su vez esta montado en la mother. El OS tiene que tener los drivers para poder soportar este tipo de hardware.

## Nivel 1 (Espejado)
- Redundancia por espejado de datos
- Se requieren `2N` discos
- Solo vale la pena cuando se necesita una alta confiabilidad

游릭 **Ventajas:**
- Un pedido de lectura puede resolverse por cualquiera de los dos discos
- La escritura se hace en forma independiente en cada disco y no se penaliza
- Simple recuperacion ante fallas
- Alta disponibilidad de datos

游댮 **Desventajas:**
- Costoso de implementar por la duplicacion de discos

![jjjj](https://github.com/user-attachments/assets/a0d8a0c1-9363-4621-9b12-251ff6329db3)

## Nivel 2 (Redundancia por codigo de Hamming)
- No tiene uso comercial
- Strips peque침os (un byte o una palabra)
- Se calcula redundancia por codigo autocorrector (ej Hamming). A traves del algoritmo se detecta alguna falla en los bits guardados y se los corrige.
- Se requieren `N + m` discos
- Se graban bits de paridad en discos separados
- Se leen/escriben todos los discos en paralelo, en forma sincronizada

游릭 **Ventajas:**
- Disponibilidad de datos

游댮 **Desventajas:**
- Costos por metodo de redundancia

## Nivel 3 (Paridad por intercalamiento de bits)
- Solo se usa **un** disco de paridad
- Se requieren `N + 1` discos
- La paridad se calcula mediante un bit a traves del conjunto individual de bits de la misma posicion de todos los discos
- Se leen/escriben todos los discos en paralelo, en forma **sincronizada**

Cuando falla alguno de esos discos, se reconstruye esa parte del disco a traves de la paridad.

Cuando se intenta **leer** datos del disco que ha fallado, toda la informacion que esta guardada en el disco que fallo se puede acceder en un "modo reducido". El sistema utiliza la informaci칩n de paridad almacenada en el disco de paridad y los datos de los discos restantes para reconstruir los datos en tiempo real. Para la lectura de informacion en esa parte fallada se regenera en el momento la informacion, ahi puede haber una peque침a degradacion de performance. 

Si se pide **escribir**, no se puede escribir directamente en el disco que ha fallado. Las escrituras se realizan en los discos restantes y la paridad se recalcula para reflejar los cambios. Esto asegura que la informaci칩n se mantenga consistente y que los datos puedan ser reconstruidos correctamente.

### Reconstruccion de los datos de un disco fallado
- La reconstrucci칩n de datos es bastante sencilla. Considerando un sistema de 5 discos, de los que de 洧녦1 a 洧녦3 contienen datos y el 洧녦4 es el de paridad. La paridad del 洧녰칠洧멇롐뒳롐뛿롐 bit se calcula de la siguiente forma: <br>
`洧녦4(洧녰) = 洧녦3(洧녰) + 洧녦2(洧녰) + 洧녦1(洧녰) + 洧녦0(洧녰)` <br>
- Siendo + la funci칩n or exclusivo
- Suponiendo que fallo la unidad 洧녦1(洧녰). Si sumamos 洧녦1(洧녰) + 洧녦1(洧녰) a los dos miembrosde la ecuaci칩n, nos quedar칤a la formula para la reconstruccion de datos del disco fallado 洧녦1:
`洧녦1(洧녰) = 洧녦4(洧녰) + 洧녦3(洧녰) + 洧녦2(洧녰) + 洧녦0(洧녰)`

游릭 **Ventajas:**
- Calculo sencillo de paridad
- No hay impacto significativo de performance ante fallas

游댮 **Desventajas:**
- Controlador complejo

![llll](https://github.com/user-attachments/assets/9e336873-81d5-4a24-85b9-c2c17986fa77)

## Nivel 4 (Paridad por intercalamiento de bloques)
- No es implementable comercialmente porque si se tuviese que guardan info que requiera usar dos discos, para calcular la paridad siempre se va a tener que usar el disco de paridad, siempre para toda operacion de lectura o escritura.
- Se accede en forma independiente a cada disco
- Se requiere `N + 1` discos
- Se puede dar servicio a pedidos de E/S en paralelo
- Se usan strips grandes
- En la teoria, los bits de paridad se calculan igual que en RAID 3 y se guarda un strip de paridad

游릭 **Ventajas:**
- Altas tasas de lectura

游댮 **Desventajas:**
- Dos lecturas y dos escrituras en caso de update de datos
- Cuello de botella por ese uso constante del disco de paridad

![iiii](https://github.com/user-attachments/assets/776644bb-af1a-4283-b0ee-a2f89eb735d3)

## Nivel 5 (Paridad por intercalamiento distribuido de bloques)
- Se accede en forma independiente a cada disco
- Se requieren `N + 1` discos
- Los strips de paridad se distribuyen en todos los discos. La paridad esta distribuida

游릭 **Ventajas:**
- Queda resuelto el cuello de botella del nivel 4 por la distribucion de la paridad.
- Puede manejar un gran n칰mero de operaciones de lectura por segundo. Ideal para aplicaciones que requieren acceso r치pido y frecuente a los datos.

游댮 **Desventajas:**
- Necesita un controlador complejo

![mmmm](https://github.com/user-attachments/assets/0d8c343b-3836-4e5a-a8f1-18941b99dd08)

## Nivel 6 (Doble paridad por intercalamiento distribuido de bloques)
Similar al nivel 5 solo que agrega paridad adicional con el motivo de aumentar la confiabilidad
- Se accede de forma independiente a cada disco
- Se requieres `N + 2` discos
- Se usan dos algoritmos de control de paridad

游릭 **Ventajas:**
- Provee disponibilidad de datos extremadamente alta, confiabilidad muy alta
- Puede soportar mas de un disco fallado

游댮 **Desventaja:**
- Controlador complejo
- Costos por doble paridad

![nnnn](https://github.com/user-attachments/assets/9f7d9d9c-4c73-4bc6-b4a8-d8f9e8f5a2f4)

## Niveles combinados
Ejemplos:

**RAID 0+1**<br>
![r1](https://github.com/user-attachments/assets/d23702e4-17ce-4af2-aa8c-fbc8fe32959c)

Son dos RAID 0 (distribucion de datos en strips) identicos que juntos conforman un RAID 1 (por la duplicacion de discos).

**RAID 5+0**<br>
![r50](https://github.com/user-attachments/assets/76e334b0-a827-430a-8389-0097a4117348)

La informacion se distribuye en los discos (RAID 0) pero incluye la redundancia del RAID 5

