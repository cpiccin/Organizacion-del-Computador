# U3 - Arquitectura del Conjunto de Instrucciones

## Arquitectura de computadoras: que puede hacer.
Son las caracteristicas computacionales visibles al programador, los atributos que tienen impacto directo en la ejecucion logica de un programa. Refiere al set de herramientas disponibles para el programador.

## Organizacion de computadoras: como lo hace.
Es la implementacion de la arquitectura (microarquitectura). Define las unidades operativas y sus interconexiones (se침ales de control, interfaces entre el CPU y los
perif칠ricos, tecnolog칤a de memoria, trayecto de datos, etc.). <br>
Por ejemplo, el como la instruccion de multiplicar se ejecuta internamente (por sumas sucesivas u otro circuito electronico). <br>
<ins>*Distintas versiones comerciales de un computador alineadas a una misma arquitectura.*</ins> <br>
<br>
Pueden haber diferentes implementaciones de una misma arquitectura por un proposito comercial donde varian:
- Costos
- Velocidad de procesamiento
- Consumo de energia

La microarquitectura es la implementaci칩n espec칤fica de una arquitectura de computadora en t칠rminos de la organizaci칩n y dise침o de sus componentes internos. Hay dos maneras genericas de construir esa microarquitectura. Se construye esa organizacion de forma:

### Cableada (hardware)
- Es un dise침o de microarquitectura en el cual las instrucciones y su ejecuci칩n est치n directamente implementadas mediante el hardware.
- Las operaciones y el flujo de control est치n codificados en la l칩gica f칤sica del procesador a trav칠s de circuitos, sin necesidad de un microc칩digo o software intermedio para interpretar las instrucciones.
- Son t칤picamente m치s r치pidas para las operaciones que est치n directamente soportadas por el hardware, pero pueden ser menos flexibles que las arquitecturas basadas en microc칩digo, ya que cualquier cambio o adici칩n al conjunto de instrucciones requiere modificaciones f칤sicas en el hardware.

### Microprogramada ("software")
- El como se ejecutan las cosas dentro del CPU se define mediante microcodigo en el hardware, secuencias de operaciones m치s simples, definidas por un microc칩digo.
- El conjunto de instrucciones del procesador no est치 directamente codificado en el hardware, sino que es definido por el microc칩digo almacenado en una memoria especial dentro del procesador.
- Pueden ser m치s lentas en la ejecuci칩n de instrucciones en comparaci칩n con las arquitecturas cableadas debido a la sobrecarga adicional de interpretar el microc칩digo, pero ofrecen ventajas significativas en t칠rminos de flexibilidad, facilidad de dise침o y capacidad para soportar un conjunto de instrucciones m치s complejo.

## Familia de computadoras
Se refiere a una 
- Misma arquitectura base, distintas organizaciones (implementaciones).
- Modelos con prestaciones y precios diferentes pero compatibles entre s칤.

## Modelo de capas
Divisi칩n de la arquitectura de computadoras en capas de forma jer치rquica, cada capa interactua con la capa inferior o superior. <br>
![capas](../assets/U3%20-%20Arquitectura%20del%20Conjunto%20de%20Instrucciones/img1.png)

### Software:

1. **Level 6 - Problem Oriented Language Level (Translation-Compiler):** This is the level of high-level programming languages like Python, Java, C++, etc. These languages are designed to be easy for humans to read and write. They are translated into machine code by compilers.

2. **Level 5 - Assembly Language Level (Translation-Assembler):** Assembly language is a low-level programming language specific to a particular computer architecture. It is converted into executable machine code by a utility program referred to as an assembler.

3. **Level 4 - Operating System Machine Level (Partial Interpretation):** This level is where the operating system resides. The OS interacts directly with the hardware and provides services to the higher level software.

4. **Level 3 - Instruction Set Architecture Level (Interpretation/Direct Execution):** This is the level of the raw machine code that is executed directly by the CPU. It is the interface between the hardware and the software.

### Hardware:

1. **Level 2 - Micro-architecture Level (Registers):** This level includes the CPU's data storage elements, such as registers and caches, and the execution units that perform operations on the data.

2. **Level 1 - Digital Logic Level (Gates):** This level is where the actual logic gates that make up the CPU are found. These gates perform basic binary logic operations like AND, OR, and NOT.

3. **Level 0 - Device Level (Individual Transistors):** This is the lowest level, where individual transistors, the building blocks of digital circuits, are found. Transistors act as electronic switches that open and close to control the flow of electricity and represent binary data.

## Clasificacion de computadoras segun su poder de calculo
| Supercomputadoras                  | Macrocomputadoras o Mainframes | Minicomputadoras o servidores middle range | Microcomputadoras / PC |Computadoras port치tiles / notebooks / netbooks | Computadoras de mano |
|------------------------------------|--------------------------------|--------------------------------------------|------------------------|-----------------------------------------------|----------------------|
| Extremadamente r치pidas             | Muy rapidas| Rapidas | Uso individual o redes peque침as a medianas | Uso individual port치til | Uso individual portatil acotado |
| Manejan vol칰menes de datos enormes | Manejan vol칰menes de datos muy grandes| Manejan volumenes de datos grandes | Manejan vol칰menes de datos no muy grandes | Manejan vol칰menes de datos no muy grandes | Manejan vol칰menes de datos peque침os |
| Poseen miles de CPU                | Poseen cientos de CPU| Poseen decenas de CPU |Poseen uno o varios CPU|Poseen uno o varios CPU|Poseen uno o varios CPU|
| Tienen usos espec칤ficos: militar, simulacion, ciencia            | Muy alta disponibilida y usos comerciales y cientificos: sistemas bancarios, telecomunicaciones, instituciones gubernamentales | Usos comerciales: empresas medianas y grandes, varios equipos en una misma empresa | Uso hogare침o, educativo, comercial, recreativo: computadora del hogar, negocios, colegios, consolas de videojuegos |Uso hogare침o, educativo, comercial, recreativo: estaciones de trabajo en empresas, computadora del hogar, negocios, colegios, consolas de videojuegos | Uso hogare침o, comercial: Acopio de datos en v칤a p칰blica, informaci칩n personal, visualizaci칩n de contenidos |

## Arquitectura Harvard
![harvarf](../assets/U3%20-%20Arquitectura%20del%20Conjunto%20de%20Instrucciones/img2.png)
![Screenshot from 2024-07-02 18-09-22](../assets/U3%20-%20Arquitectura%20del%20Conjunto%20de%20Instrucciones/img3.png) <br>
La memoria de la maquina esta subdividida en dos espacios distintos, una para almacenar datos y otra para almacenar las instrucciones, el programa que hace uso de esos datos.<br>
Ahora el CPU interactua con dos memorias, cada una con un bus dedicado.
#### Puntos a considerar:
- La ventaja de tener dos memorias independientes tiene que ver con poder acceder de forma simuntanea a una instruccion y a un dato, poder cargar al mismo tiempo instrucciones y datos (instruction fetch y data access en paralelo por distintos buses).
- Como dificultad esta que como hay dos memorias diferentes se manejan espacios de direcciones diferentes lo que dificulta la programacion al tener que hacer esa diferenciacion.
- Es implementado en algunos microcontroladores PIC y en procesadores de se침ales digitales. 
- Usado en los DSP (tipo especializado de microprocesador dise침ado espec칤ficamente para realizar operaciones de procesamiento de se침ales digitales de manera eficiente) para streaming de datos:
 * Mayor ancho de banda de memoria. 
 * Ancho de banda m치s predecible. 
- En la pr치ctica, las diferencias en el rendimiento de acceso entre las arquitecturas Harvard y Von Neumann pueden no ser tan significativas como en la teor칤a, especialmente en aplicaciones generales de prop칩sito general. Adem치s, la complejidad de la programaci칩n en una arquitectura Harvard puede limitar su uso en ciertos contextos.

|Diferencias de rendimiento|Complejidad de programacion|Aplicaciones especializadas|
|--------------------------|---------------------------|---------------------------|
| Teoricamente, Hardvard puede ofrecer ventajas por el acceso simultaneo a datos e instrucciones, pero en la practica no es tan notable ese rendimiento. Se debe a que otros factores como la velocidad de la memoria, la optimizacion del codigo, pueden influir mas en ese rendimiento general | La separacion de datos e instrucciones puede complejizar la programacion. Von Neumann tiene una abstraccion mas simple donde los datos y las instrucciones se manejan de manera mas uniforme. | Hardvard es mas adecuada para aplicaciones especializadas que necesiten un acceso rapido y eficiente a la memoria  como en sistemas embebidos, procesamiento de se침ales, control en tiempo real, etc.|

## ISA (Instruction Set Architecture) - Arquitectura de Programacion:

### Repertorio de instrucciones
Instrucciones de maquina; instrucciones que entiende nativamente el CPU. 

#### <ins>쯈u칠 es una instrucci칩n de m치quina?</ins> 
- Una instruccion que entiende directamente el CPU de la maquina.
- Las instrucciones son visibles para el CPU dentro del registro de instrucciones.
- Cuando la "ve" (hizo el fetch desde la memoria) va a la fase de la instruccion en si.
- Tiene la forma `Opcode + Operandos (0 a n)`

#### Categorias:
- Aritmeticas y logicas
  * add, substract, divide, multiply
  * and, or, xor
- Movimiento de datos
  * load, store, move
- Entrada / Salida
  * start I/O (input/output)
- Control de flujo: metodos para evaluar condiciones de bifurcacion.
  * **Condition Code (CC)**, Ej: Intel x86, ARM, Power Pc, SPARC: Este m칠todo utiliza un conjunto de bits especiales, conocidos como condition codes, que se actualizan seg칰n el resultado de ciertas operaciones, como sumas, restas o comparaciones. Despu칠s de una operaci칩n, se establecen los bits de los condition codes seg칰n el resultado, como el bit de cero si el resultado es cero, el bit de signo si el resultado es negativo, etc. Las instrucciones de bifurcaci칩n pueden examinar estos bits de condici칩n para decidir si se debe tomar una rama en el flujo de ejecuci칩n del programa.
  * **Condition Register**. Ej: Alpha, MIPS: Similar al m칠todo de los condition codes, el Condition Register es un registro especial que contiene informaci칩n sobre el resultado de la 칰ltima operaci칩n realizada. En lugar de bits individuales como en el m칠todo CC, el Condition Register puede contener un campo dedicado para indicar si la 칰ltima operaci칩n result칩 en igualdad, menor que, mayor que, etc. Las instrucciones de bifurcaci칩n pueden examinar directamente este registro para tomar decisiones basadas en el resultado de la operaci칩n anterior.
  * **Compare and Branch**. Ej: VAX: Este m칠todo implica realizar una comparaci칩n directa entre dos valores y luego tomar una decisi칩n de bifurcaci칩n basada en el resultado de esa comparaci칩n. Por lo general, implica una instrucci칩n de comparaci칩n que resta un valor de otro y establece los bits de condici칩n apropiados (como en el m칠todo CC). Luego, una instrucci칩n de bifurcaci칩n condicional puede examinar estos bits de condici칩n y tomar una decisi칩n de salto basada en ellos. Por ejemplo, si el resultado de la comparaci칩n fue igual, puede tomar una rama; de lo contrario, puede tomar la otra.
  
#### Tipos de operandos
- Registro
- Memoria
- Inmediato

#### Clasificacion segun la ubicacion de los operandos
Segun la implementacion de la arquitectura cambia donde va a estar el operando para poder realizar la instruccion.
- Stack
- Acumulador (abacus)
- Registro-Memoria (superabacus)
- Registro-Registro (load-store) (suberabacus)
- Memoria-Memoria

Resolucion de `C = A + B` segun cada arquitectura:
![adsd](../assets/U3%20-%20Arquitectura%20del%20Conjunto%20de%20Instrucciones/img4.png)

#### Clasificacion de la ISA segun el numero de direcciones
- 0 direcciones (Stack): add 
- 1 direcci칩n (Acumulador): add A
- 2 direcciones (Reg-Mem/Reg-Reg/Mem-Mem): add R1, A
- 3 direcciones (Reg/Mem): add R1, R2, R3

### Tipos de datos
- Num칠ricos (BPF s/s, BPF c/s, BPFlotante, BCD). 
- Caracteres (ASCII, EBCDIC, Unicode) 
- Datos l칩gicos 
- Direcciones

### Modos de direccionamiento
Toda instruccion de maquina tiene operandos, el acceso a esos operandos se llama direccionamiento. Cual es la forma que tiene el CPU de acceder a los datos necesarios para ejecutar la instruccion. <br>

![modo](../assets/U3%20-%20Arquitectura%20del%20Conjunto%20de%20Instrucciones/img5.png) <br>

Previo veo <ins>componentes de la velocidad de transferencia</ins>:
- Latencia: cuanto tarda en que el dato viaje del registro hasta la UAL (cuanto tarda en recorrer el camino de apertura de compuertas)
- Cuan rapido es el componente electronico para transmitir la informacion a traves del camino.
#### Inmediato 
El operando se encuentra en la instruccion. <br>
游릭 No es necesario acceder a la memoria para obtener el dato, lo que hace que este modo sea muy rapido. <br>
游댮 La limitacion es que como el operando forma parte de la instruccion, va a tener un tama침o limitado por el tama침o de la instruccion.
#### Memoria Directo
La direccion de memoria donde se encuentra el operando se especifica en la instruccion. <br>
游릭 La ventaja es que como el operando esta guardado en la memoria, su tama침o es libre.<br>
游댮 La limitacion es como la del modo inmediato, por ahi no entra la address completa; tambien otra limitacion es que la direccion esta prefijada, se puede modificar el contenido de la memoria pero la direccion es fija, no hay tanta flexibilidad.
#### Memoria Indirecto
La direcci칩n de memoria donde se encuentra el operando se almacena en otra direcci칩n de memoria. La instrucci칩n especifica la direcci칩n de memoria que contiene la direcci칩n real del operando.<br> 
游릭 La ventaja es acceder a datos cuya ubicaci칩n puede cambiar durante la ejecuci칩n, hay una mayor flexibilidad ademas de que tambien no va a existir esa limitacion del tama침o de direccion en la segunda instruccion.<br>
游댮 Como hay dos accesos a memoria la instruccion sera muy lenta.
#### Registro
El operando se encuentra en un registro del procesador. <br>
游릭 Este modo permite un acceso muy r치pido a los datos, ya que los registros son m치s r치pidos que la memoria. <ins>**Va a ser un modo mas rapido que el inmediato**</ins> porque los registros se encuentran en la UAL y el operando inmediato se encuentra en el RI que esta en la Unidad de Control, por el camino de datos y el acceso a compuertas, el acceso a un registro va a ser mas rapido. <br>
游댮 La limitacion de este modo esta en que como la cantidad de registros es limitada no se puede almacenar todo en registros y usar este modo todo el tiempo; otra limitacion es el tama침o del registro. 
#### Registro Indirecto
La direcci칩n de memoria del operando se almacena en un registro. <br>
游릭 Combina la velocidad de acceso de los registros con la flexibilidad del direccionamiento indirecto.<br>
游댮 La desventaja es el direccionamiento adicional hacia la memoria
#### Desplazamiento. *Offset*
Se basa en modificar una direccion base para acceder a distintos operandos. La direccion efectiva se construye con dos datos.<br>
游릭 La ventaja es la gran flexibilidad por poder modificar dos datos
- Relativo (Program counter): se especifica el offset como una cantidad de bytes a donde la maquina va a ir a buscar el operando. Lo va a buscar a esa distancia en bytes de direccion de la instruccion, que esta en el Program counter que es el RPI.
- Registro Base: se suma un desplazamiento a un registro con la direccion de memoria para obtener la direcci칩n del operando. Utilizado para acceder a estructuras de datos como arrays y structs.
- Indexado: el desplazamiento que se suma esta en el registro (un indice) y el otro dato sera la direccion base a la que se le suma. Esto es especialmente 칰til para trabajar con arrays, donde el 칤ndice indica el elemento espec칤fico.
#### Stack
Para las instrucciones que lo usan, no van a tener operandos porque el operando va a estar implicito en el tope de la pila.

### Formato de Instrucciones (Encoding)
Define como cada arquitectura especifica que campos y que bits componen cada instruccion.

#### Componentes
- Opcode
- 0 a n operandos
- Modo de direccionamiento de cada operando
- Flags

<ins> **Formato fijo** </ins>: todas las instrucciones de m치quina tienen el mismo tama침o de instrucci칩n, a pesar de poder tener distinto formato.
En **ARM** todas las instrucciones de ARM miden 32 bits<br>
<p>
  <img src="../assets/U3%20-%20Arquitectura%20del%20Conjunto%20de%20Instrucciones/img6.png" alt="arm" style="display: block; margin-left: auto; margin-right: auto; width: 300px;" />
</p>

<ins> **Formato variable** </ins>: el tama침o de las instrucciones de m치quina depende de c칩mo se escriba la instrucci칩n.<br>
En **x86** es un unico formato variable (el tama침o de cada campo es variable) <br>
<p>
  <img src="../assets/U3%20-%20Arquitectura%20del%20Conjunto%20de%20Instrucciones/img7.png" alt="arm" style="display: block; margin-left: auto; margin-right: auto; width: 300px;" />
</p>

<ins> **Formato hibrido** </ins>: mezcla entre fijo y variable. Hay distintos formatos, cada uno tiene un tama침o definido, por lo que el tama침o depende de c칩mo combine los formatos. <br>
En **IBM Mainframe** el formato de instruccion varia pero cada uno a su vez es fijo


### Memoria
  * **Word size:** cantidad de bits que el CPU puede procesar de manera nativa en una operacion. Este concepto coincide directamente con el tama침o en bits de la arquitectura. Por ejemplo en 8086 el word size era de 16 bits pero actualmente hay procesadores de 64 bits entonces, por ejemplo en un programa Intel para guardar un BPF c/s se tendria que pedir una `qword` que son 8 bytes o sea 64 bits. En ARM que es basado en 32 bits, una `word` van a ser 32 bits y una `dword` seran 64 bits
  * **Big/Little Endian:** cuando se guarda algo en la memoria puede cambiar el orden en el que se almacena y lee un dato.
    - Big Endian: el byte m치s significativo se coloca primero (en la direccion de memoria mas baja) y el menos significativo se coloca al final (en la direccion mas alta)
    - Little Endian: el byte menos significativo se almacena en la direccion mas baja y el mas significativo en la mas alta
    - Ejemplo: `12345678[16] BPF c/s 32 bits` el numero se divide en 4 bytes donde 12 es el mas significativo y 78 el menos significativo, entonces:
      |Direc|BE|LE|
      |-----|--|--|
      | 184 |12|78|
      | 185 |34|56|
      | 186 |56|34|
      | 187 |78|12|  
  * **Direccionamiento (Celda):** generalmente el tama침o de las celdas de memoria es de un byte.
  * **Espacio de direcciones:** se refiere al conjunto de todas las direcciones de memoria que un sistema inform치tico o un proceso puede acceder. Estas direcciones pueden referirse a ubicaciones f칤sicas de memoria en hardware o a ubicaciones virtuales que son gestionadas por el sistema operativo.


